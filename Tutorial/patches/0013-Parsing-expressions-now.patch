From d7764cc24c8f91427554fa0bae4788a07a8e3480 Mon Sep 17 00:00:00 2001
From: Jaipal Singh <jpsinghgoud@gmail.com>
Date: Tue, 3 Jul 2018 12:50:24 +0530
Subject: [PATCH 13/47] Parsing expressions now

---
 examples/arithematic_parser.py | 202 +++++++++++++++++++++++++++++++++++++++++
 examples/proc_interpreter.py   |   8 +-
 examples/script.py             |  65 ++++++++++++-
 3 files changed, 266 insertions(+), 9 deletions(-)
 create mode 100644 examples/arithematic_parser.py

diff --git a/examples/arithematic_parser.py b/examples/arithematic_parser.py
new file mode 100644
index 0000000..9bde792
--- /dev/null
+++ b/examples/arithematic_parser.py
@@ -0,0 +1,202 @@
+from __future__ import division
+
+import os
+import sys
+import re
+
+
+INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF, DECIMAL = (
+    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF', '.'
+)
+
+
+class Token(object):
+    def __init__(self, type, value):
+        self.type = type
+        self.value = value
+
+    def __str__(self):
+        """String representation of the class instance.
+
+        Examples:
+            Token(INTEGER, 3)
+            Token(PLUS, '+')
+            Token(MUL, '*')
+        """
+        return 'Token({type}, {value})'.format(
+            type=self.type,
+            value=repr(self.value)
+        )
+
+    def __repr__(self):
+        return self.__str__()
+
+
+class Lexer(object):
+    def __init__(self, text):
+        # client string input, e.g. "4 + 2 * 3 - 6 / 2"
+        self.text = text
+        # self.pos is an index into self.text
+        self.pos = 0
+        self.current_char = self.text[self.pos]
+
+    def error(self):
+        raise Exception('Invalid character')
+
+    def advance(self):
+        """Advance the `pos` pointer and set the `current_char` variable."""
+        self.pos += 1
+        if self.pos > len(self.text) - 1:
+            self.current_char = None  # Indicates end of input
+        else:
+            self.current_char = self.text[self.pos]
+
+    def skip_whitespace(self):
+        while self.current_char is not None and self.current_char.isspace():
+            self.advance()
+
+    def integer(self):
+        """Return a (multidigit) integer consumed from the input."""
+        result = ''
+        while self.current_char is not None and self.current_char.isdigit() or self.current_char == '.':
+            result += self.current_char
+            self.advance()
+        return float(result)
+
+    def get_next_token(self):
+        """Lexical analyzer (also known as scanner or tokenizer)
+
+        This method is responsible for breaking a sentence
+        apart into tokens. One token at a time.
+        """
+        while self.current_char is not None:
+
+            if self.current_char.isspace():
+                self.skip_whitespace()
+                continue
+
+            if self.current_char.isdigit():
+                return Token(INTEGER, self.integer())
+
+            if self.current_char == '.':
+                return Token(INTEGER, self.integer())
+
+            if self.current_char == '+':
+                self.advance()
+                return Token(PLUS, '+')
+
+            if self.current_char == '-':
+                self.advance()
+                return Token(MINUS, '-')
+
+            if self.current_char == '*':
+                self.advance()
+                return Token(MUL, '*')
+
+            if self.current_char == '/':
+                self.advance()
+                return Token(DIV, '/')
+
+            if self.current_char == '(':
+                self.advance()
+                return Token(LPAREN, '(')
+
+            if self.current_char == ')':
+                self.advance()
+                return Token(RPAREN, ')')
+
+            self.error()
+
+        return Token(EOF, None)
+
+
+class Interpreter(object):
+    def __init__(self, lexer):
+        self.lexer = lexer
+        # set current token to the first token taken from the input
+        self.current_token = self.lexer.get_next_token()
+
+    def error(self):
+        raise Exception('Invalid syntax')
+
+    def eat(self, token_type):
+        # compare the current token type with the passed token
+        # type and if they match then "eat" the current token
+        # and assign the next token to the self.current_token,
+        # otherwise raise an exception.
+        if self.current_token.type == token_type:
+            self.current_token = self.lexer.get_next_token()
+        else:
+            self.error()
+
+    def factor(self):
+        """factor : INTEGER | LPAREN expr RPAREN"""
+        token = self.current_token
+        if token.type == INTEGER:
+            self.eat(INTEGER)
+            return token.value
+        elif token.type == LPAREN:
+            self.eat(LPAREN)
+            result = self.expr()
+            self.eat(RPAREN)
+            return result
+
+    def term(self):
+        """term : factor ((MUL | DIV) factor)*"""
+        result = self.factor()
+
+        while self.current_token.type in (MUL, DIV):
+            token = self.current_token
+            if token.type == MUL:
+                self.eat(MUL)
+                result = result * self.factor()
+            elif token.type == DIV:
+                self.eat(DIV)
+                result = result / self.factor()
+
+        return result
+
+    def expr(self):
+        """Arithmetic expression parser / interpreter.
+
+        calc> 7 + 3 * (10 / (12 / (3 + 1) - 1))
+        22
+        
+        Rules : 
+        expr   : term ((PLUS | MINUS) term)*
+        term   : factor ((MUL | DIV) factor)*
+        factor : INTEGER | LPAREN expr RPAREN
+        """
+        result = self.term()
+
+        while self.current_token.type in (PLUS, MINUS):
+            token = self.current_token
+            if token.type == PLUS:
+                self.eat(PLUS)
+                result = result + self.term()
+            elif token.type == MINUS:
+                self.eat(MINUS)
+                result = result - self.term()
+
+        return result
+
+
+def main():
+    while True:
+        try:
+            try:
+                text = raw_input('calc> ')
+            except NameError:  # Python3
+                text = input('calc> ')
+        except EOFError:
+            break
+        if not text:
+            continue
+        lexer = Lexer(text)
+        interpreter = Interpreter(lexer)
+        result = interpreter.expr()
+        print(result)
+
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/examples/proc_interpreter.py b/examples/proc_interpreter.py
index 812a07c..a1b1e49 100644
--- a/examples/proc_interpreter.py
+++ b/examples/proc_interpreter.py
@@ -31,16 +31,14 @@ import sys
 import re
 import os
 
-class Procudre():
+class Procedure():
 	"""
 	Common class for all procedures.
 	Each unique procedure is an instance of this class
 	"""
 
-	def __init__(self, proc_name, proc_args, global_vars):
+	def __init__(self, proc_name, proc_args, global_vars, element):
 		self.name = proc_name
 		self.args = proc_args
 		self.global_vars = global_vars
-
-	def initialize(self):
-
+		self.proc_string = element
\ No newline at end of file
diff --git a/examples/script.py b/examples/script.py
index b80194b..ba78997 100644
--- a/examples/script.py
+++ b/examples/script.py
@@ -25,12 +25,14 @@ How the script parser works :
 	** Return a list of commands (Eg : in sph.s sph ...) from the prob objects
 ** In a serial order draw all the shapes as required from this script module.
 '''
-
+from __future__ import division
 import argparse
 import errno
 import sys
 import os
 import brlcad.wdb as wdb
+from proc_interpreter import Procedure
+from arithematic_parser import *
 from brlcad.primitives import *
 
 global_vars = {}
@@ -40,7 +42,21 @@ def index_containing_substring(the_list, substring):
 	for i, s in enumerate(the_list):
 		if substring in s:
 			  return i
-	return -1
+	return len(the_list)
+
+def find_between(s, first, last):
+    try:
+        start = s.index( first ) + len( first )
+        end = s.index( last, start )
+        return s[start:end]
+    except ValueError:
+        return ""
+
+def replace_vars(my_string):
+	x = my_string
+	for variable in global_vars:
+		x = x.replace(variable, str(global_vars[variable]))
+	return x
 
 def parse_var(command):
 	var_name = "$"+str(command[1])
@@ -73,7 +89,46 @@ def initalize_global_vars(commands):
 		command_type = element[0]
 		if command_type == "set": 
 			switcher[command_type](element)
-	print(global_vars)				#debug
+
+def calculate_value(text):
+	print(text)
+	text = text.replace("{", "(")
+	text = text.replace("}", ")")
+	text = text.strip()
+	lexer = Lexer(text)
+	interpreter = Interpreter(lexer)
+	result = interpreter.expr()
+	print(result)
+	return float(result)
+
+def evaluate_expressions(commands):
+	print("ERE")
+	for command in commands:
+		if "exp" in command:
+			broken = command.split("[")
+			mystring = ""
+			'''
+			We iterate over any every command after its split at "["
+			and evaluate any expressions that might be present.
+			Because that's how expressions are meant to be written
+			'''
+			for element in broken:
+				if "exp" in element:
+					'''
+					mystring now holds the the text contained within an expression
+					Eg : 
+					> [exp{$j - $i}]
+					> mystring = {$j - $i}
+					'''
+					my_string = find_between(element, "exp", "]")
+					text = replace_vars(my_string)
+					result = calculate_value(text)
+					to_replace = "[" + element
+					print(to_replace)
+					command = command.replace(to_replace.strip(), str(result))
+					print(command)
+
+
 
 def create_proc_objects(proc_list):
 	for element in proc_list:
@@ -81,7 +136,8 @@ def create_proc_objects(proc_list):
 		proc_name = temp_list.split()[1]
 		proc_args = temp_list.split("{")[1].split('}')[0].split()
 		print(proc_args)											#debug
-		script_procedures[proc_name] = Procedure(proc_name, proc_args, global_vars)
+		print("Creating Object for each procedure now")
+		script_procedures[proc_name] = Procedure(proc_name, proc_args, global_vars, element)
 
 def parse_procs(commands, proc_line_position):
 	proc_list = []
@@ -153,6 +209,7 @@ def parse_primitive(command):
 def parse_script(database_name, units, commands):
 	initalize_global_vars(commands)
 	initialize_procs(commands)
+	evaluate_expressions(commands)
 	exit()
 
 	for element in commands:
-- 
2.14.3 (Apple Git-98)

