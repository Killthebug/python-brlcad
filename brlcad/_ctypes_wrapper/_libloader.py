"""
brlcad._ctypes_wrapper._libloader
~~~~~~~~~~~~~~~~

Helper functions related to loading BRL-CAD shared libraries. In particular,
direct attention to `load`.

This is all necessary because I can't seem to get ctypes to find any of the
libraries. Hopefully this file can be removed in the near future. Maybe if
someone less sleepy looks over it?

Most of this is inspired by code found in ctypesgen output. That stuff should
probably be distributed as a separate library or module in general, which is
why it's isolated and hacked into this file.

This file is highly derivative of code generated by ctypesgen. Check cytypesgen
for licensing information (it's open source, but I forget the name of the
license that I am looking at here.)

Copyright (c) 2013 Bryan Bishop <kanzure@gmail.com>
Copyright (c) 2008 David James
Copyright (c) 2006-2008 Alex Holkner
"""

import sys
import os
import platform
import glob

import ctypes
import ctypes.util

BRLCAD_LIBRARY_PATHS = [
    # grr why does it install to this completely non-standard path?
    "/usr/brlcad/lib/",
]

DARWIN_NAME_FORMATS = [
    "lib{0}.dylib",
    "lib{0}.so",
    "lib{0}.bundle",
    "{0}.dylib",
    "{0}.so",
    "{0}.bundle",
    "{0}",
]

WINDOWS_NAME_FORMATS = [
    "{0}.dll",
    "lib{0}.dll",
    "{0}lib.dll",
]

LINUX_NAME_FORMATS = [
    "{0}.so",
    "lib{0}.so",
]

LINUX_ENVIRONMENT_PATHS = [
    "LD_LIBRARY_PATH",
    "SHLIB_PATH", # HPUX
    "LIBPATH", # OS/2, AIX
    "LIBRARY_PATH", # BE/OS
]

LINUX_LIBRARY_PATHS = [
    "/lib",
    "/usr/lib",
    "/lib64",
    "/usr/lib64",
]

class WindowsLibrary(object):
    """
    Some python magic for finding an attribute on a Windows library.
    """

    def __init__(self, path):
        self.cdll = ctypes.cdll.LoadLibrary(path)
        self.windll = ctypes.windll.LoadLibrary(path)

    def __getattr__(self, name):
        try:
            return getattr(self.cdll, name)
        except AttributeError:
            try:
                return getattr(self.windll, name)
            except AttributeError:
                raise

def environ_path(name):
    if name in os.environ:
        return os.environ[name].split(":")
    else:
        return []

def make_mac_osx_search_paths(libname):
    """
    Implements the dylib search as specified in Apple documentation.

    http://developer.apple.com/documentation/DeveloperTools/Conceptual/DynamicLibraries/Articles/DynamicLibraryUsageGuidelines.html

    Before commencing the standard search, the method first checks the bundle's
    ``Frameworks`` directory if the application is running within a bundle (OS
    X .app).
    """

    dyld_fallback_library_path = environ_path("DYLD_FALLBACK_LIBRARY_PATH")

    if not dyld_fallback_library_path:
        dyld_fallback_library_path = [
            os.path.expanduser("~/lib"),
            "/usr/local/lib",
            "/usr/lib",
        ]

    dirs = []

    if "/" in libname:
        dirs.extend(environ_path("DYLD_LIBRARY_PATH"))
    else:
        dirs.extend(environ_path("LD_LIBRARY_PATH"))
        dirs.extend(environ_path("DYLD_LIBRARY_PATH"))

    dirs.append(".")
    dirs.append(os.path.dirname(__file__))

    if hasattr(sys, "frozen") and sys.frozen == "macosx_app":
        frozenpath = os.path.join(os.environ["RESOURCEPATH"], "..", "Frameworks")
        dirs.append(frozenpath)

    dirs.extend(dyld_fallback_library_path)

    return dirs

def find_paths(libname):
    """
    Make up a list of plausible search paths based on the system platform.
    """
    paths = list()

    if sys.platform == "darwin":
        searchpaths = make_mac_osx_search_paths(libname)
        paths.extend(searchpaths)
    elif sys.platform in ["win32", "cygwin"]:
        raise NotImplementedError
    else: # probably POSIX
        path = ctypes.util.find_library(libname)
        if path:
            paths.append(os.path.join("/lib", path))

        for name in LINUX_ENVIRONMENT_PATHS:
            paths.extend(os.environ.get(name, "").split(os.pathsep))

        try:
            paths.extend([dir.strip() for dir in open("/etc/ld.so.conf")])
        except IOError:
            pass

        if sys.platform.startswith("linux"):
            # https://wiki.ubuntu.com/MultiarchSpec
            bitage = platform.architecture()[0]
            if bitage.startswith("32"):
                # assume intel/amd x86 compat
                paths.extend(["/lib/i386-linux-gnu", "/usr/lib/i386-linux-gnu"])
            elif bitage.startswith("64"):
                # assume intel/amd x86 compat
                paths.extend(["/lib/x86_64-linux-gnu", "/usr/lib/x86_64-linux-gnu"])
            else:
                # guess..
                paths.extend(glob.glob("/lib/*linux-gnu"))

        paths.extend(LINUX_LIBRARY_PATHS)

        # TODO: port _create_ld_so_cache from ctypesgen?

    # relative paths.. unlikely, but who knows?
    paths.append(os.path.abspath("."))
    paths.append(os.path.dirname(__file__))

    # this one has never worked for me :(
    paths.append(ctypes.util.find_library(libname))

    # whatever custom places brlcad might stuff itself
    paths.extend(BRLCAD_LIBRARY_PATHS)

    # filter out None
    return [path for path in paths if path not in ["", " ", None]]

def find_library_path(libname, paths=None, throw=True):
    """
    Searches for the library in the usual locations. Returns the path to the
    library.
    """
    if not paths:
        paths = find_paths(libname)

    names = []

    if sys.platform == "darwin":
        if os.path.pathsep in libname:
            names.append(libname)
        else:
            names.extend([frag.format(libname) for frag in DARWIN_NAME_FORMATS])
    elif sys.platform in ["win32", "cygwin"]:
        names.extend([frag.format(libname) for frag in WINDOWS_NAME_FORMATS])
    else:
        names.extend([frag.format(libname) for frag in LINUX_NAME_FORMATS])

    for name in names:
        for pathfrag in paths:
            path = os.path.join(pathfrag, name)
            if os.path.exists(path):
                return path

    if throw:
        raise ImportError(
            "Library {0} not found.".format(libname)
        )

def load_library_by_path(libpath):
    """
    Attempt to load a library at a specific path.
    """
    try:
        # Darwin requires dlopen to be called with mode RTLD_GLOBAL instead of
        # the default RTLD_LOCAL. Without this, you end up with libraries not
        # being loadable, resulting in "Symbol not found" errors.
        if sys.platform == "darwin":
            library = ctypes.CDLL(libpath, ctypes.RTLD_GLOBAL)
        elif sys.platform in ["cygwin", "win32"]:
            library = WindowsLibrary(libpath)
        else:
            library = ctypes.cdll.LoadLibrary(libpath)
    except OSError as error:
        raise ImportError(error)
    else:
        return library

def load(libname):
    """
    Finds the library and loads it into ctypes.
    """
    libpath = find_library_path(libname)
    library = load_library_by_path(libpath)
    return library
